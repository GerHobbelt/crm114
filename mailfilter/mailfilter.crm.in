#! @BIN_PATH@/crm114
#    -- bangline args removed for system portability --
# -( learnspam learnnonspam learngood learnfile stats_only config spamcss nonspamcss goodcss fileprefix force unlearn cache )
#
# A statistical mail sorter with mail-to-yourself commanding
#
# Copyright (C) 2002-2008 William S. Yerazunis; licensed under the
# GNU Public License (GPL) version 2.  A copy of this license is included
# in the distribution media, or obtain one from www.fsf.org .
#
# Note to SunOS and FreeBSD users - you MUST remove EVERYTHING on
# the first line of this program from the first "-" to the end of
# the first line (including the "-" sign itself) or you will not get
# what you expect.  This is due to "differences of opinion" on how
# a bangline should be dealt with.
#

window

{
    isolate (:_arg2:)
    match [:_arg2:] /--help/
    output /This is MailFilter, the 2nd Generation mail filter "standard script"\n/
    output /for CRM114.  The goal is to make a more maintainable, understandable,\n/
    output /and easier-to-customize mail filter.\n/
    output /\n/
    output /1) we use the consolidated library "maillib.crm" for most shareable\n/
    output /   things like parsing the .cf file, munging text, cacheing text, etc.\n/
    output /\n/
    output /2) we always use the CacheIDs and the Reaver (maildir-like) format\n/
    output /   for storing incoming email in unaltered form if there is\n/
    output /   any possibility of training it.\n/
    output /\n/
    output /3) We always train using mailtrainer.crm rather than training\n/
    output /   internally.  Thus, if you want to change the way things are\n/
    output /   trained, you need to look at mailtrainer.crm as well.\n/
    output /\n/
    output /\n/
    output /We use the mailfilter.cf configuration setup file.\n/
    output /\n/
    output /You *must* supply at least an email via input redirection\n/
    output /or by specifying a --mailfile=<file> input.\n/
    output /\n/
    output /Command Format:\n/
    output /      .\/mailfilter.crm [options]*\n/
    output /\n/
    output /Required options:\n/
    output / --spam=\/spam\/directory\/    (one msg per file)\n/
    output / --good=\/good\/directory\/    (one msg per file)\n/
    output /\n/
    output /Optional options:\n/
    output /\n/
    output / --mailfile=<file> - point at email input file. Use when you\n/
    output /                     don't want to feed mailreaver an email via\n/
    output /                     stdin.  Default: wait for input on stdin.\n/
    output / --mailout=<file>  - Write the processed email to <file>.\n/
    output /                     Default: write to stdout.\n/
    output / --spamcss=spam_statistics.css\n/
    output /                   - use that as the spam CSS file (Default: spam.css)\n/
    output / --goodcss=good_statistics.css\n/
    output /                   - use that as the ham CSS file (Default: nonspam.css)\n/
    output / --learnspam       - learn as spam and exit\n/
    output / --learngood       - learn as nonspam and exit\n/
    output / --force           - force-feed the learning: learn always, not only\n/
    output /                     when message to learn is incorrectly classified.\n/
    output / --learnfile=filename\n/
    output /                   - Learn :filename: into :filename:.css and store\n/
    output /                     the file content in :filename:text.txt.\n/
    output /\n/
    output /We also support the following commands on both the command line\n/
    output /in the form "--blahblah --blahblah" and by using the\n/
    output /"command {secretpassword} word word" method in the email body:\n/
    output /\n/
    output / --spam            - This is spam.  Treat appropriately.[*]\n/
    output / --good            - This is good.  Treat appropriately.[*]\n/
    output / --cache           - Pretend the email starts on the following line.\n/
    output /                     Process it normally and put it in the cache.\n/
    output / --dontstore       - Do NOT store this text into the cache.  Use\n/
    output /                     this for text that you never want to train.\n/
    output / --stats_only      - Output ONLY the status.  Nothing else.\n/
    output /                     Since this means there's no output of the\n/
    output /                     CacheIDs, we don't store the text for later training.\n/
    output / --report_only     - Output ONLY the headers that would have\n/
    output /                     been added, not the entire text.\n/
    output / --verbose         - Tell me more.\n/
    output / --verbose_startup - Tell me more about the commands and options being\n/
    output /                     decoded.\n/
    output / --fileprefix=dir  - Look in this dir for the .css, .cf and .txt files\n/
    output /                     (expect all files in "fileprefix", except '--config')\n/
    output / --config=filename - Use filename as the .cf file. Default is mailfilter.cf\n/
    output /\n/
    output /These commands are only accepted from the email body:\n/
    output /\n/
    output /   maxprio +\/-     - Add a maximum priority entry\n/
    output /   minprio +\/-     - Add a minimum priority entry\n/
    output /   delprio         - Delete a prio list entry.\n/
    output /   learn <filename> <content>\n/
    output /                   - Train <content> into :filename:.css (forced) and\n/
    output /                     store the file content in :filename:text.txt.\n/
    output /\n/
    output /[*] - meaning that if it's a command line flag, the entire\n/
    output /      standard input is the example text and if it's an inline\n/
    output /      command, then the example text follows the inline commandline.\n/
    exit
}

#
# --->>>     Design Philosophy ( do these IN ORDER )
#
# * if --fileprefix is specified, all filenames EXCEPT --config
#   are prefixed with that (You need a trailing slash on the prefix
#   if it is a directory name.)
#
# * if --config , grab the config file from the specified place.
#
# * Load the mailfilter.cf config file from wherever config or
#   fileprefix points (--config overrides --fileprefix).
#
# * If --spamcss is specified, use that as the spam.css file
#
# * If --nonspamcss is specified, use that as the nonspam.css file
#
# * If --learnspam, learn as spam and exit.
#
# * If --learnnonspam, learn as nonspam and exit
#
# * If --force, force-feed the learning
#
# * If --learnfile, use :learnfile:.css and :learnfile:text.txt
#
# * If --stats_only, do normal classification but don't do any
#   forwarding, only output the status on stdout and return
#   the exit code.
#
# * check for the "command word", if present, execute the command
#
# * check to see if any of the whitelist patterns apply.  If so,
#   accept the mail to /var/spool/the_user (which is actually to
#   be found at /var/spool/mail/:*:_env_USER:
#
# * check to see if any of the blacklist patterns apply.  If so,
#   flush the mail to the "blacklisted" file.
#
# * check to see if it's commanded to be learned as a spam or a
#   nonspam model.  If so, learn it to the appropriate .css (Crm
#   Sparse Spectra) file
#
# * run the email through the classifier.  If the classifier thinks
#   it's good, send it to the /var/spool/mail/the_user file, else
#   send it to the "doubtful" file.
#
##############################################################
#
# ---  uncomment this if you want to include a "forced"
#      configuration file  ---
# insert mailfilterconfig.crm
#
#
# --- These vars must have a value, or else we'll get errors ----
#
isolate (:program_fault_exit_code:) /66/   # [i_a] in case mailfilter.cf cannot be loaded: make sure we don't get an error report cascade.
#
isolate <default> (:fileprefix:) //
#
isolate (:classifier_reason:) /no reason yet/
#
isolate (:classify_status:) //
#
isolate (:our_exit_code:) /0/
#
isolate (:stats:) / pR: 0.000000 /
#
isolate (:pr:) / pR: 0.00000/
#
isolate (:subj_text:) / (None) /
#
isolate (:add_extra_stuff:) //
#
isolate (:decision_length:) /4096/
#
isolate (:cachedir:) //
isolate (:cacheid:) //
isolate (:msg_hash:) //
#
#      Isolate these email addresses, and give them values,
#      in case the user doesn't.
isolate (:reject_address:) //
isolate (:unsure_address:) //
isolate (:fail_priority_mail_to:) //
isolate (:fail_classify_mail_to:) //
isolate (:fail_blacklist_mail_to:) //
isolate (:fail_SSM_mail_to:)  //
isolate (:log_rejections:) //

#
#       now, :clf: is the classify & learn flags; note that we have two
#       separate flags here in a bizarre chain.  The reason is that :unlearn:
#       can have the value "SET", whereas :rft: needs "refute"
isolate (:clf:) //
#
#       and someplace to catch mailtrainer if we need it.
isolate (:mailtrainer_output:) //
#
isolate (:c:) //

#####################################################################
#
#       This is the code to read the per-user configuration.  Note
#       that because this happens during the run, it will _override_
#       any command line arguments that get set.

isolate (:verbose_startup:) <default> //
isolate <default> (:config:) /:*:fileprefix:mailfilter.cf/

#
# read in the options/configuration file
#
call /:load_cf_file:/ [:*:config:]

#
# make sure verbose_logfile has a valid, non-empty value, so output is NOT logged to stdout
# unless we explicitly say so.
#
{
    eval /:@: :#:verbose_logfile: <= 2 :/    # a valid filename? assume at least 2 chars
    alter (:verbose_logfile:) /stderr/
}

###########################################################
#    Set up defaults for mail scoring...
#
isolate <default> (:mailfile:) //
isolate <default> (:mailout:) //
isolate <default> (:learnspam:) //
isolate <default> (:learnnonspam:) //
isolate <default> (:learnfile:) //
isolate (:stats_only:) <default> //
isolate (:cache:) <default> //
isolate (:verbose:) <default> //
isolate (:force:) <default> //
isolate (:unlearn:) <default> //
isolate <default> (:learngood:) /:*:learnnonspam:/

#
# Make sure we know who our CSS files are.
#
isolate (:spamcss:) <default> /spam.css/
isolate (:nonspamcss:) <default> /nonspam.css/
isolate (:goodcss:) <default> /:*:nonspamcss:/

# make sure to truncate the logfile:
{
    match [:verbose:] /SET/
    output [:*:verbose_logfile:] /Start of mailfilter sessions\n/
}

#
#     Now, a tricky bit - we need to add "unlearn" to the :clf:
#     if it was in the line params - but we have to append, not replace,
#     because :clf: (CLassfier Flags) also contains the classifier we use.
#
{
    match [:unlearn:] /SET/
    alter (:clf:) /:*:clf: refute/
}

#######################################################################
#
#    Do a quick check - has the password been changed or not?  If it's
#    still the default, put in something that will be well-nigh unguessable
#    (esp. since it will contain received headers that the sender cannot
#    see nor control.)
{
    match [:spw:] /DEFAULT-PASSWORD/
    # yes, it's the same as default.  So we scramble it just so
    # nobody can hack in without major trickery.
    hash (:spw:) /:*:_env_string::*:_dw:/
}

######################################################################
#
#     Set up the addresses that we might need to mail to
#
#     if a particular "fail" category hasn't been assigned, but
#     the :general_fails_to: category has, then send there instead
#
isolate (:reject_address:) /:*:general_fails_to:/
{
    match [:fail_priority_mail_to:] <absent> /[[:graph:]]/
    alter (:fail_priority_mail_to:) /:*:general_fails_to:/
}
{
    match [:fail_blacklist_mail_to:] <absent> /[[:graph:]]/
    alter (:fail_blacklist_mail_to:) /:*:general_fails_to:/
}
{
    match [:fail_SSM_mail_to:] <absent> /[[:graph:]]/
    alter (:fail_SSM_mail_to:) /:*:general_fails_to:/
}
{
    match [:fail_classify_mail_to:] <absent> /[[:graph:]]/
    alter (:fail_classify_mail_to:) /:*:general_fails_to:/
}

#########################################################################
#
#       READ THE EMAIL FROM FILE / STDIN
#
#########################################################################
#
input [:*:mailfile:]

{
    match [:verbose_startup:] /SET/
    output [:*:verbose_logfile:] /verbose = :*:verbose:\n/
    call /:verbosity:/ [mailfile = :*:mailfile:]
}


#########################################################################
#
#       START OF ACTUAL MAIL PROCESSING HERE
#
#########################################################################
#
#      Does the user want us to log all incoming mail?  This is handy for
#      testing and auditing purposes; by default it is turned off in the
#      configuration file.
#
{
    match [:log_to_allmail.txt:] /yes/
    call /:verbosity:/ [Append mail to logfile :*:fileprefix:allmail.txt]
    output [:*:fileprefix:allmail.txt] <append> /:*:mail_separator:/
    output [:*:fileprefix:allmail.txt] <append> /:*:_dw:/
}

#     allow logging to anywhere...
{
    match [:log_all_mail_to_file:] /./
    call /:verbosity:/ [Append mail to logfile :*:fileprefix::*:log_all_mail_to_file:]
    output [:*:fileprefix::*:log_all_mail_to_file:] <append> /:*:mail_separator:/
    output [:*:fileprefix::*:log_all_mail_to_file:] <append> /:*:_dw:/
}

###################################################################
#
#       See if there's already a CacheID in the headers- if so, grab it.
#
isolate (:cacheid:) //
{
    # only use CacheID when we _have_ a cache
    match [:text_cache:] /./
    {
        match [:in_text:] <nomultiline> (:: :cacheid:)  \
                /X-CRM114-CacheID:.*sfid-([[:graph:]]+)/
        isolate (:cacheid:)
        isolate (:long_cacheid:) /:*:text_cache:\/texts\/:*:cacheid:/
    }
    alius    #  nope, not in the explicit headers.  Check for it as a
    #           comment in the Message-Id: header.
    {
        match [:in_text:] <nomultiline> (:: :cacheid:)  \
                /Message-Id:.*\(sfid-([[:graph:]]+)\)/
        isolate (:cacheid:)
        isolate (:long_cacheid:) /:*:text_cache:\/texts\/:*:cacheid:/
    }
    #      ADD OTHER PLACES TO CHECK HERE
}

call /:verbosity:/ [CacheID detection turned up:\n  cacheID: :*:cacheid:\n  long_cacheID: :*:long_cacheid:]


####################################################################
#
#      Do we save the text into the cache, or has that already happened
#
# Unless "dontstore" is set or we already have a CacheID, we're supposed
# to save the text.  Saving is the usual case, mind you.  Normally this
# is the whole text, but if we had an inline "command cache" line then
# use whatever text follows the "command password cache" line and stuff
# that into the cache rather than the whole text.  You don't normally
# need to do this except as a prelude to training this new text.
#
{
    match <absent> [:cacheid:] /./
    match <absent> [:dontstore:] /SET/
    #      yes - so the text to be worked follows the command line.
    #      which is already in :in_text:   This also calculates the
    #      new cacheids named :cacheid: and :long_cacheid: .
    call /:verbosity:/ [Save content in Reaver Cache?]
    call /:reavercache_init:/
    call /:reavercache_store:/ [:*:_dw:]
}



##############################################################
#
#      Grab the text that we're going to actually work with.
#
#      We copy this into m_text - the "mutilated text".  It
#      will become an annotated _copy_  of the incoming text,
#      with whatever changes we think will help us classify better.
#

#
#   To start with, the commanded text is assumed to be the entire input.
#   THEN
#   If there's a command followed by text, we save the text so we can
#   put that, and _only_ that, into the .txt corpi.
{
    isolate (:cmd_txt:) /:*:_dw:/
    match (:: :cmd_txt:) [:_dw:] /command :*:spw: [^\n]*\n(.*)/
}

call /:mail_preprocess:/  [:_dw:] (:m_text:)


###################################################################
#
#    Command Dispatch processing starts here
#
#  ---------do we have a --learnspam or --learnnonspam command line key?
#
match (:text:) [:m_text:] /.*/

{
    match [:learnspam:] /SET/
    goto /:learnspamhere:/
}
{
    match [:learngood:] /SET/
    goto /:learngoodhere:/
}
{
    match (:trash: :file:) [:learnfile:] /(.+)/
    goto /:learntofilehere:/
}

#
#
#------------  Are we enabled for "inoculations" via email?
#
{
    match [:inoculations_enabled:] /yes/
    #
    #  see if we have an inoculation header.
    #
    match <nomultiline> [:m_text:] \
        /Inoculation-Sender: ([[:graph:]]+)/ (:x: :sender:)
    match <nomultiline> [:m_text:] \
        /Inoculation-Type: ([[:graph:]]+)/ (:x: :type:)
    match <nomultiline> [:m_text:] \
        /Inoculation-Authentication: (.*)$/ (:x: :auth:)
    #
    #   See if the sender is in our list, and if so, what is their secret?
    #
    isolate (:inoculation_passwd:) //
    input (:inoculation_passwd:) [:*:fileprefix:inoc_passwd.txt]
    match [:inoculation_passwd:] <nomultiline> \
        /:*:sender: :*:type: (.*)/ (:x: :secret:)
    #
    #    We now have the shared secret, calculate the checksum we should have
    #
    #     grab the body...
    match /\n\n(.*)/ (:x: :body:)
    #
    #     and calculate the hash.
    isolate (:md5out:)
    syscall (:*:secret::*:_nl::*:body:) (:md5out:) /md5sum/
    match [:md5out:] /([[:graph:]]+)/ (:x: :md5out:)
    #
    #     does this hash match with the given hash?
    match [:auth:] /:*:md5out:/
    #
    #     Yes, it matched.  It's a real innoculation.
    #
    #     grab the text we want to actually learn (this is the payload)
    match [:m_text:] (:x: :text:) /\n\n(.*)/
    #
    #     and learn it appropriately
    {
        match [:type:] /nonspam/
        goto /:learngoodhere:/
    }
    alius
    {
        match [:type:] /good/
        goto /:learngoodhere:/
    }
    alius
    {
        match [:type:] /spam/
        goto /:learnspamhere:/
    }
}
########################################################################
#
#       2) Check for a command.  Set flags as appropriate.  Note that we
#       can't just dispatch on the presence of a flag, because we need
#       to merge in anything that might be in an inline command.
#
########################################################################
#
#      Our commands are of the form:
#
#      command password <command>  extra_args
#
#      and the extra_args are one or more of
#       spam
#       good
#       nonspam
#       learn
#       cache
#       dontstore
#       stats_only
#       verbose          <-- was previously unused [i_a]
#
#
#    Start our searching at the start of our input.
#        If nothing else requires it, we use the current input as the
#        text to be operated upon.
#
# -------------check for the COMMAND WORD ----------
#
{
    #
    #    grab the password as :pw:, and any arg(s) as :c:
    #
    match <nomultiline> (:z: :pw: :c: ) [:_dw:] /^command ([[:graph:]]+) (.*)/
    #
    #    check the password.  If it's invalid, FAIL out of this bracket set
    #    and just treat this as ordinary (non-command) mail.
    match [:pw:] /:*:spw:/
    {
        #    was it a command to add something to the whitelist?
        match <nomultiline> (:q: :a:) [:c:] /whitelist (.*)/
        output [:*:fileprefix:whitelist.mfp] <append> /:*:a::*:_nl:/
        alter (:z:) /*** :*:z: *** :*:_nl:Whitelist command executed! :*:_nl:/
        accept
        exit /:*:accepted_mail_exit_code:/
    }
    {
        #    was it a command to add something to the blacklist?
        match <nomultiline> (:q: :a:) [:c:] /blacklist (.*)/
        output [:*:fileprefix:blacklist.mfp] <append> /:*:a::*:_nl:/
        alter (:z:) /*** :*:z: *** :*:_nl:Blacklist command executed! :*:_nl:/
        accept
        exit /:*:accepted_mail_exit_code:/
    }
    #
    #    Did the user specify command "force"?
    #
    {
        match <nomultiline> [:c:] /force/
        #
        #    yep, so we set the "force" on.
        alter (:force:) /SET/
    }

    #
    #    Did the user specify command "unlearn"?
    #
    {
        match <nomultiline> [:c:] /unlearn/
        #
        #    yep, so we set the "force" on.
        alter (:unlearn:) /SET/
    }
    #
    #     Now, if :unlearn: is set, by either bashline or command, we
    #     set the :clf: flag to be "refute".   Otherwise, we set it to
    #     be what it was before.
    #
    {
        match [:unlearn:] /SET/
        alter (:clf:) /:*:clf: refute/
    }


#####################################################################
#####################################################################
#
#       Command flags are all set; at this point we can run strictly from
#       the :var: values and the text held in :in_text:
#
#####################################################################
#####################################################################


    #
    #     Now, the big mahonka.  Learn as nonspam, or as spam
    #      (note the three subpaths - one each for non-forced, forced, and
    #      non-forced error messages)
    #

    {
        #     was it a command to learn something as nonspam?
        {
            match [:c:] /nonspam/
            match (:z: :text:) [:m_text:] /:*:_nl:command [[:graph:]]+ nonspam(.*)/
        }
        alius
        {
            match [:c:] /good/
            match (:z: :text:) [:m_text:] /:*:_nl:command [[:graph:]]+ good(.*)/
        }
        #      and learn it as nonspam
:learngoodhere:
        {
            #     Are we supposed to use the cached version?
            {
                    match [:c:] /cache/
                    alter (:cache:) /SET/
            }
            match [:cache:] /SET/        # can also be set on command line
            #      yes - so we use mailtrainer.crm to do the training
            {
                match (:: :cacheid:) /X-CRM114-CacheID: ([[:graph:]]+)/
                #      check- does the cached file exist?
                syscall () (:tmp:) /ls :*:text_cache:\/texts\/:*:fileid:/
                match [:tmp:] /:*:fileid:/
                #   yes, it exists - go on with the learning method
                #      and remember this file on a permanent basis
                syscall /:*:cache_dupe_command: :*:text_cache:\/texts\/:*:fileid: :*:text_cache:\/known_good\/:*:fileid: /
                isolate (:mailtrainer_output:) //
                call /:verbosity:/ [Gonna learn using:\n:*:trainer_invoke_command: --fileprefix=:*:fileprefix: --good=:*:text_cache:\/known_good\/:*:cacheid: --spam=:*:text_cache:\/empty\/]
                syscall /:*:trainer_invoke_command: --fileprefix=:*:fileprefix: --good=:*:text_cache:\/known_good\/:*:fileid: --spam=:*:text_cache:\/empty\/ / () (:mailtrainer_output:)
                call /:verbosity:/ [mailtrainer output:  ':*:mailtrainer_output:']

                #      and remove it from the prob_* directories, as
                #      now it's known
                {
                    match [:_hosttype:] /Windows-MS/
                    call /:mk_dospath:/ [:*:text_cache:\/prob_spam\/:*:cacheid:] (:dospath:)
                    syscall /del \/f \/q :*:dospath:/
                    call /:mk_dospath:/ [:*:text_cache:\/prob_good\/:*:cacheid:] (:dospath:)
                    syscall /del \/f \/q :*:dospath:/
                }
                alius
                {
                    syscall /\/bin\/rm -f  :*:text_cache:\/prob_spam\/:*:cacheid:/
                    syscall /\/bin\/rm -f  :*:text_cache:\/prob_good\/:*:cacheid:/
                }
                #
                #      now it's trained; put in a marker in the headers
                call /:mungmail_delete:/ [X-CRM114-Status: ]
                call /:mungmail_delete:/ [X-CRM114-Unsure: ]
                call /:mungmail_add:/ [X-CRM114-Action: LEARNED AND CACHED NONSPAM ]
                #   Insert the training report into the msgbody if desired
                {
                    match [:add_mailtrainer_report:] /yes/
                    match (:: :firstline:) /.*(.)/
                    match (:: :firstline:) /\n\n()/
                    alter (:firstline:) / :*:mailtrainer_output:\n-----\n/
                }
                accept
                exit /:*:accepted_mail_exit_code:/
            }
            #   No, it didn't exist.  Add an error message header.
            call /:mungmail_add:/ [X-CRM114-ERROR: No cached text with that cacheID, so nothing done!]
            accept
            exit /:*:unsure_mail_exit_code:/
        }
        {
            #  No cacheing, so we learn "natively"
            #
            #    Verify that we need to learn this first (TOE strategy)
            classify <:*:clf:> [:text:] /:*:lcr:/ \
              (:*:fileprefix::*:goodcss: | :*:fileprefix::*:spamcss: ) \
              (:classify_status:)
            match [:classify_status:] <nomultiline> \
                    /^#0.* pR: ([-. 0-9]+)/ (:: :pr:)
            eval /:@: :*:pr: < :*:good_threshold: :/    # was comparison against 'thick_threshold'
            {
                match [:log_to_nonspamtext:] /yes/
                output [:*:fileprefix:nonspamtext.txt] <append> /\n\n:*:cmd_txt:\n/
            }
            #
            #     write out the pre-mutilation text, with newlines
            #
            learn <:*:clf:> (:*:fileprefix::*:goodcss:) [:text:] /:*:lcr:/
            call /:mungmail_add:/ [X-CRM114-Action: LEARNED NONSPAM]
            call /:mungmail_unique:/ [X-CRM114-Status: Good (Learn)]
            accept
            exit /:*:accepted_mail_exit_code:/
        }
        alius
        {
            #
            #    Did the user specify "--force" on the command line?
            match [:force:] /SET/
            {
                match [:log_to_nonspamtext:] /yes/
                output [:*:fileprefix:nonspamtext.txt] <append> /\n\n:*:cmd_txt:\n/
            }
            #
            #     write out the pre-mutilation text, with newlines
            #
            learn < :*:clf: > (:*:fileprefix::*:goodcss:) [:text:] /:*:lcr:/
            call /:mungmail_add:/ [X-CRM114-Action: LEARNED NONSPAM (FORCED)]
            call /:mungmail_unique:/ [X-CRM114-Status: Good (Learn)]
            accept
            exit /:*:accepted_mail_exit_code:/
        }
        alius
        {
            call /:mungmail_add:/ [X-CRM114-Action: LEARN AS NONSPAM UNNECESSARY- ALREADY CLASSIFIED CORRECTLY - NO ACTION TAKEN]
            accept
            exit /:*:accepted_mail_exit_code:/
        }
    }
    {
        #     was it a command to learn something as spam?
        match [:c:] /spam/
        match (:z: :text:) [:m_text:] /:*:_nl:command [[:graph:]]+ spam(.*)/
        #      and learn it as spam
:learnspamhere:
        {
            #     Are we supposed to use the cached version?
            {
                match [:c:] /cache/
                alter (:cache:) /SET/
            }
            match [:cache:] /SET/        # can also be set on command line
            #      check- does the cached file exist?
            {
                #      yes - so we use mailtrainer.crm to do the training
                match (:: :fileid:) /X-CRM114-CacheID: ([[:graph:]]+)/
                syscall () (:tmp:) /ls :*:text_cache:\/texts\/:*:fileid:/
                match [:tmp:] /:*:fileid:/
                #      remember this file on a permanent basis
                syscall /:*:cache_dupe_command: :*:text_cache:\/texts\/:*:fileid: :*:text_cache:\/known_spam\/:*:fileid: /
                isolate (:mailtrainer_output:) //
                call /:verbosity:/ [Gonna learn using:\n:*:trainer_invoke_command: --fileprefix=:*:fileprefix: --spam=:*:text_cache:\/known_spam\/:*:cacheid: --good=:*:text_cache:\/empty\/]
                syscall /:*:trainer_invoke_command: --fileprefix=:*:fileprefix: --spam=:*:text_cache:\/known_spam\/:*:cacheid: --good=:*:text_cache:\/empty\/ / () (:mailtrainer_output:)
                call /:verbosity:/ [mailtrainer output:  ':*:mailtrainer_output:']

                #      and remove it from the prob_* directories, as
                #      now it's known
                {
                    match [:_hosttype:] /Windows-MS/
                    call /:mk_dospath:/ [:*:text_cache:\/prob_spam\/:*:cacheid:] (:dospath:)
                    syscall /del \/f \/q :*:dospath:/
                    call /:mk_dospath:/ [:*:text_cache:\/prob_good\/:*:cacheid:] (:dospath:)
                    syscall /del \/f \/q :*:dospath:/
                }
                alius
                {
                    syscall /\/bin\/rm -f  :*:text_cache:\/prob_spam\/:*:cacheid:/
                    syscall /\/bin\/rm -f  :*:text_cache:\/prob_good\/:*:cacheid:/
                }
                #
                #      now it's trained; put in a marker in the headers
                call /:mungmail_delete:/ [X-CRM114-Status: ]
                call /:mungmail_delete:/ [X-CRM114-Unsure: ]
                call /:mungmail_add:/ [X-CRM114-Action: LEARNED AND CACHED SPAM]
                #   Insert the training report in the msgbody, if desired
                {
                    match [:add_mailtrainer_report:] /yes/
                    match (:: :firstline:) /.*(.)/
                    match (:: :firstline:) /\n\n()/
                    alter (:firstline:) / -------\n :*:mailtrainer_output:\n ------ \n/
                }
                accept
                exit /:*:accepted_mail_exit_code:/
            }
            alius
            {
                call /:mungmail_add:/ [X-CRM114-ERROR: No cached text with that cacheID, so nothing done! ]
                accept
                exit /:*:unsure_mail_exit_code:/
            }
        }
        {
            #      Not cached...
            #
            #    Verify that we need to learn this first (TOE strategy)
            classify <:*:clf:> [:text:] /:*:lcr:/ \
                    (:*:fileprefix::*:goodcss: | :*:fileprefix::*:spamcss: )\
                    (:classify_status:)
            match [:classify_status:] <nomultiline> \
                    /^#0.* pR: ([-. 0-9]+)/ (:: :pr:)
            # eval /:@: :*:pr: > (0 - :*:thick_threshold:) : /
            eval /:@: :*:pr: > :*:spam_threshold: : /   # are we not yet recognized as spam?
            #
            #     write out the pre-mutilation text, with newlines
            #
            {
                match [:log_to_spamtext:] /yes/
                output [:*:fileprefix:spamtext.txt] <append> /\n\n:*:cmd_txt:\n/
            }
            learn < :*:clf:> (:*:fileprefix::*:spamcss:) [:text:] /:*:lcr:/
            call /:mungmail_add:/ [X-CRM114-Action: LEARNED SPAM]
            call /:mungmail_unique:/ [X-CRM114-Status: Good (Spam Learn)]
            accept
            exit /:*:accepted_mail_exit_code:/
        }
        alius
        {
            #    Did the user specify "--force" on the command line?
            match [:force:] /SET/
            #
            #     write out the pre-mutilation text, with newlines
            #
            {
                match [:log_to_spamtext:] /yes/
                output [:*:fileprefix:spamtext.txt] <append> /\n\n:*:cmd_txt:\n/
            }
            learn < :*:clf:> (:*:fileprefix::*:spamcss:) [:text:] /:*:lcr:/
            call /:mungmail_add:/ [X-CRM114-Action: LEARNED SPAM (FORCED)]
            call /:mungmail_unique:/ [X-CRM114-Status: Good (Spam Learn)]
            accept
            exit /:*:accepted_mail_exit_code:/
        }
        alius
        {
            call /:mungmail_add:/ [X-CRM114-Action: LEARN AS SPAM UNNECESSARY- ALREADY CLASSIFIED CORRECTLY - NO ACTION TAKEN]
            call /:mungmail_unique:/ [X-CRM114-Status: Good (Spam Learn)]

            accept
            exit /:*:accepted_mail_exit_code:/
        }
    }
    {
        #     was it a command to learn something as an arbitrary type?
        # Note: the files this generates don't get used for anything unless
        #  you use --spamcss and --nonspamcss in your own scripts.
        #
        # Note: these "learns" are a-priori "force", since we don't know
        #  what other .css files we should compare this text to.
        #
        match [:c:] /learn/
        match (:z: :learnfile: :text:) [:m_text:] /:*:_nl:command [[:graph:]]+ learn ([[:graph:]]+)(.*)/
        #      and learn it
:learntofilehere:
        output [:*:fileprefix::*:learnfile:text.txt] <append> /:*:text:/
        learn < :*:clf:> (:*:fileprefix::*:learnfile:.css) [:text:] /:*:lcr:/
        call /:mungmail_add:/ [X-CRM114-Action: LEARNED :*:file:]
        call /:mungmail_unique:/ [X-CRM114-Status: Good (Learn)]
        accept
        exit /:*:accepted_mail_exit_code:/
    }
}


##########################################################################
#
#      Not a learn, so it's a CLASSIFY job.  Maybe full, maybe stats_only.
#
#     classify this incoming mail:
#     first according to priority action list,
#     then according to whitelist,
#     then according to blacklist,
#     then according to the CRM sparse spectral classifier.
#
#     check it against the priority action list- this list is
#     of the form of a + or -, then a pattern.  + means accept,
#     - means reject.  These are executed in order (which is
#     different from whitelist or blacklist in that they occur
#     in order given, not whitelist-then-blacklist.  The priority
#     action list is tried before whitelist or blacklist.
#
isolate (:priolist:) //
input (:priolist:) [:*:fileprefix:priolist.mfp]
#    reset matching on :priolist: to the start of the string
match [:priolist:] //
#
#
{
    #... Grab the next regex, turn the one-per-line patterns into a regex
    match <fromend nomultiline> (:w: :pm: :pat:) [:priolist:]  /(.)(.+)/
    #... see if this regex matches the incoming mail
    {
        match <nomultiline> (:reason:) /:*:pat:/
        #  Yep, it matched... branch based on pm
        #
        {
            match [:pm:] /[+]/
            # put in a little tag saying why prio-listed
            alter (:classifier_reason:) /** ACCEPT: CRM114 Priority Whitelisted by: :*:reason: **:*:_nl:/
            alter (:stats:) /Match to priority pattern :*:pat:\n Forced pR: 999.99 /
            match [:stats:] (:: :pr:) /Forced pR: ([[:graph:]]+)/
            goto /:looks_good:/
        }
        #   No, we didn't have a +, was it a '-'?
        {
            match [:pm:] /[-]/
            alter (:classifier_reason:) /** REJECT: CRM114 Priority Blacklisted by: :*:reason: **:*:_nl:/
            alter (:reject_address:) /:*:fail_priority_mail_to:/
            {
                match [:log_rejections:] /yes/
                output [:*:fileprefix:rejected_by_blacklist.txt] <append> /:*:_dw:/
            }
            alter (:stats:) /Match to priority pattern :*:pat:\n Forced pR: -999.99 /
            match [:stats:] (:: :pr:) /pR: ([[:graph:]]+)/
            goto /:looks_spam:/
        }
    }
    #   Nope, didn't match as a priority... grab the next regex until
    #   there are no prio-list regexes left
    liaf
}
#
#
#     check it against the whitelist... load the whitelist...
{
    isolate (:whitelist:)
    input (:whitelist:) [:*:fileprefix:whitelist.mfp]
    #    reset matching on whitelist to start of string
    match [:whitelist:] //
}
#
#
{
    #... Grab the next regex, turn the one-per-line patterns into a regex
    match <fromend nomultiline> (:waste: :whregex:) [:whitelist:]  /(.+)/
    #... see if this regex matches the incoming mail
    {
        match <nomultiline> (:reason:) /:*:whregex:/
        #  Yep, it matched... whitelist this email
        #
        # put in a little tag saying why whitelisted:
        alter (:classifier_reason:) /** ACCEPT: CRM114 Whitelisted by: :*:reason: **:*:_nl:/
        alter (:stats:) /Match to whitelist pattern :*:pat:\n Forced pR: 999.99 /
        match [:stats:] (:: :pr:) /pR: ([[:graph:]]+)/
        goto /:looks_good:/
    }
    #   Nope, didn't match... grab the next regex and try again,
    liaf
}

#
#    No joy, maybe we should blacklist it.
#
#     check it against the blacklist
{
    isolate (:blacklist:)
    input (:blacklist:) [:*:fileprefix:blacklist.mfp]
    #    reset matching on blacklist to start of string
    match [:blacklist:] //
}
#
{
    #... Grab the next regex, turn the one-per-line patterns into a regex
    match <fromend nomultiline> (:waste: :blregex:) [:blacklist:]  /(.+)/
    #... see if this regex matches the incoming mail
    {
        match <nomultiline> (:reason:) /:*:blregex:/
        #  Yep, it matched... blacklist this email
        #
        # put in a little tag saying why blacklisted
        alter (:classifier_reason:) /** REJECT: CRM114 Blacklisted by: :*:reason: ** :*:_nl:/
        alter (:reject_address:) /:*:fail_blacklist_mail_to:/
        {
            match [:log_rejections:] /yes/
            output [:*:fileprefix:rejected_by_blacklist.txt] <append> /:*:_dw:/
        }
        alter (:stats:) /Match to blacklist pattern :*:pat:\n Forced pR: -999.99 /
        match [:stats:] (:: :pr:) /pR: ([[:graph:]]+)/
        goto /:looks_spam:/
    }
    #   Nope, didn't match... grab the next regex and try again
    liaf
}
#
#
#
#    End of blacklist processing.
#

#######################################################################
#
#
#      All else has failed- we now run our CLASSIFY algorithm
#       to make our best guess.
#
#
{
    # Run the CSS classifier against the "expanded" text -
    # if it classifies as SPAM
    #   then reject it as SPAM.
    #
    {
        classify <:*:clf:> ( :*:fileprefix::*:goodcss: | :*:fileprefix::*:spamcss: ) ( :stats: ) [:m_text:] /:*:lcr:/
    }
    #       Now we grab the pR and if it's greater than the minus
    #       threshold, we send it to "good".  Otherwise, it goes to bad.
    {
        match <nomultiline> [:stats:] (:d: :pval:) /pR: (.*)/
        eval /:@: :*:pval: > ( 0.0 - :*:thick_threshold: ) : /
        alter (:classifier_reason:) /** ACCEPT: CRM114 PASS :*:clf: Matcher ** :*:_nl::*:stats:/
        goto /:looks_good:/
    }
    alter (:classifier_reason:) /** REJECT: CRM114 FAIL :*:clf: Matcher ** :*:_nl::*:stats:/
    alter (:reject_address:) /:*:fail_SSM_mail_to:/
    {
        match [:log_rejections:] /yes/
        output [:*:fileprefix:rejected_by_css.txt] <append> /:*:_dw:/
    }
    goto /:looks_spam:/
}
#
#
#         Final wrap-up routines - dispose of the mail as appropriate.
#
:looks_spam:
{
    #   is this a :stats_only: run (i.e. for CAMRAM)
    {
        match [:stats_only:] /SET/
        match <nomultiline> [:stats:] (:d: :pval:) /pR: (.*)/
        output /:*:pval: :*:_nl:/
        alter (:our_exit_code:) /:*:rejected_mail_exit_code:/
        goto /:finish_up:/
    }

    #    not stats_only.... we're doing major output.

    #       save unprocessed text by symlink in the text cache if needed.
    {
        match [:text_cache:] /./
        match [:cacheid:] /./
        syscall () () /:*:cache_dupe_command: :*:text_cache:\/texts\/:*:cacheid: :*:text_cache:\/prob_spam\/:*:cacheid:/
    }

    #     and write out the long-form message too.
    {
        {
            match [:add_headers:] /yes/
            {
                match <nomultiline> [:stats:] (:pr:) /pR: .*$/
            }
            call /:mungmail_add:/ [X-CRM114-Version: :*:_crm_version: MF-:*:_pgm_hash: ]
            call /:mungmail_unique:/ [X-CRM114-CacheID: :*:cacheid: ]
            call /:mungmail_unique:/ [X-CRM114-Status: SPAM  ( :*:pr: )]
        }
        #
        #            Now, get the Subject: line.  If none, make one.
        {
            {
                match (:subject_line: :subj_text:) <nocase nomultiline> \
                     /^Subject: (.*)/
            }
            alius
            {
                match (:end_of_headers:) /\n\n/
                alter (:end_of_headers:) /\nSubject: (none)\n\n/
                match (:subject_line: :subj_text:) <nomultiline> /^Subject: (.*)/
            }
        }
        {
            #
            #   If we are re-sending this, we want to de-fang the
            #   subject, otherwise we don't.
            match [:reject_address:]  /[a-zA-Z0-9]/
            #   Paolo P. suggests this alteration to avoid subversion
            #   by enclosing an alternate target in "marks".  We always
            #   have to do this.
            {
                match (:dq:) [:subj_text:] /\$/
                alter (:dq:) /USD/
                liaf
            }
            {
                match (:dq:) [:subj_text:] /[^-a-zA-Z0-9!., ]/
                alter (:dq:) //
                liaf
            }
            #
            #     We isolate subj_text here, so if later syscalls move
            #     things, the subject text used in "mail" is still OK.
            isolate (:subj_text:)
        }
        #
        #     If the user asked for a spam-flagging string, put the flagging
        #     string into the subject.
        #
        {
            match [:spam_flag_subject_string:] /./
            alter (:subj_text:) /:*:spam_flag_subject_string: :*:subj_text:/
        }
        {
            match [:add_extra_stuff:] /text/
            #   get rid of any first-column 'From's as they are message breaks!
            #   this isn't necessary if we're mailing to someplace else...
            {
                match (:f:) <nomultiline> [:m_text:] /^From/
                alter (:f:) />:*:f:/
                liaf
            }
            alter (:_dw:) /:*:_dw:-=-Extra Stuff-=-\n\n:*:m_text: -0-0-0- :*:_nl:/
        }
        {
            match [:add_extra_stuff:] /attachment/
            #   get rid of any first-column 'From's as they are message breaks!
            #   this isn't necessary if we're mailing to someplace else...
            {
                match (:f:) <nomultiline> [:m_text:] /^From/
                alter (:f:) / :*:f:/
                liaf
            }


            isolate (:content_type:) //
            call /:mungmail_extract:/ [Content-type] (:content_type:)
            isolate (:content_transfer_encoding:) //
            call /:mungmail_extract:/ [Content-Transfer-Encoding] (:content_transfer_encoding:)
            call /:mungmail_add:/ ["Content-Type: multipart\/mixed\; boundary=Attachment_Quote_Boundary_1234567890\n--Attachment_Quote_Boundary_1234567890\n:*:content_type::*:content_transfer_encoding:]
            alter (:_dw:) /:*:_dw::*:_nl:\
--Attachment_Quote_Boundary_1234567890 :*:_nl:\
Content-Type: text\/plain :*:_nl:\
Content-Transfer-Encoding: quoted-printable \n\n\n:*:m_text:\
\n--Attachment_Quote_Boundary_1234567890--\n/
        }

        #
        #
        #     Decide if we forward or if we just output it.
        {
            {
                #   if this match succeeds, we should forward-to-an-address?
                # Yes, but only if we _have_ a forward-to address.
                match [:reject_address:]  /[a-zA-Z0-9]/
                {
                    #  -- put the classifier reason in as the first thing!
                    match [:add_verbose_stats:] /yes/
                    alter (:_dw:) /:*:_nl: :*:classifier_reason::*:_nl: :*:_dw: /
                }
                syscall (:*:_dw:) /:*:mail: :*:reject_address: -s ':*:subj_text:'/
            }
            alius
            {
                {
                    # -- put the classifier reason in at the end of the headers
                    match [:add_verbose_stats:] /yes/
                    match (:start_of_data:) /\n\n/
                    alter (:start_of_data:) /\n\n :*:classifier_reason: \n /
                }
                accept
            }
        }
    }
    alter (:our_exit_code:) /:*:rejected_mail_exit_code:/
}
goto /:finish_up:/


#
#          and here's where we accept something as good email.
:looks_good:
{
    #   is this a :stats_only: run (i.e. for CAMRAM)
    {
        match [:stats_only:] /SET/
        match <nomultiline> [:stats:] (:d: :pval:) /pR: (.*)/
        output /:*:pval: :*:_nl:/
        alter (:our_exit_code:) /:*:accepted_mail_exit_code:/
        goto /:finish_up:/
    }

    # Not stats-only; do the full output thing.

    # save unprocessed txt by symlink in the text cache if needed.
    {
        match [:text_cache:] /./
        match [:cacheid:] /./
        syscall /:*:cache_dupe_command: :*:text_cache:\/texts\/:*:cacheid: :*:text_cache:\/prob_good\/:*:cacheid: /
    }


    # and generate up a pretty mail-out report.
    {
        match [:add_verbose_stats:] /yes/
        alter (:_dw:)  /:*:_dw: :*:_nl: :*:classifier_reason: :*:_nl:/
    }
    {
        match [:add_headers:] /yes/
        {
            match <nomultiline> [:stats:] (:pr:) /pR: .*$/
        }
        call /:mungmail_add:/ [X-CRM114-Version: :*:_crm_version: MF-:*:_pgm_hash: [:*:pr:]]
        call /:mungmail_unique:/ [X-CRM114-CacheID: :*:cacheid: ]
        call /:mungmail_unique:/ [X-CRM114-Status: Good  ( :*:pr: )]
        {
            # Maybe we need to tag it as unsure?  Note that since mail
            # that scores > -thresh (but still < 0)goes out the "good" pipe,
            # some "spammy" email might come through here.
            match <nomultiline> [:stats:] (:d: :pval:) /pR: (.*)/
            eval /:@: :*:pval: < :*:thick_threshold: :/
            call /:mungmail_unique:/ [X-CRM114-Status: UNSURE (:*:pval:) This message is 'unsure'; please train it! ]
        }
    }
    {
        match [:add_extra_stuff:] /text/
        #   get rid of any first-column 'From's as they are message breaks!
        #   this isn't necessary if we're mailing to someplace else...
        {
            match (:f:) <nomultiline> [:m_text:] /^From/
            alter (:f:) / :*:f:/
            liaf
        }
        alter (:_dw:) /:*:_dw:-=-Extra Stuff-=-\n\n :*:m_text: -0-0-0- \n/
    }
    {
        match [:add_extra_stuff:] /attachment/
        #   get rid of any first-column 'From's as they are message breaks!
        #   this isn't necessary if we're mailing to someplace else...
        {
            match (:f:) <nomultiline> [:m_text:] /^From/
            alter (:f:) / :*:f:/
            liaf
        }
        isolate (:content_type:) //
        call /:mungmail_extract:/ (:content_type:) [Content-Type]
        isolate (:content_transfer_encoding:) //
        call /:mungmail_extract:/ (:content_transfer_encoding:) [Content-Transfer-Encoding:]
        call /:mungmail_add:/ [MIME-Version: 1.0]
        call /:mungmail_unique:/ [Content-Type:]
        alter (:_dw:) /:*:_dw::*:_nl:\
--Attachment_Quote_Boundary_1234567890 :*:_nl:\
Content-Type: text\/plain :*:_nl:\
Content-Transfer-Encoding: quoted-printable \n\n\n:*:m_text:\
\n--Attachment_Quote_Boundary_1234567890--\n/
    }

    accept
    alter (:our_exit_code:) /:*:accepted_mail_exit_code:/
}
goto /:finish_up:/


#
#         Here's where we finish up processing in all the paths.
#
:finish_up:




:exit_here:
exit /:*:our_exit_code:/




################################################################
#
#        Catch failures.

trap (:broken_program_message:) /.*/
{
    #accept
    output [:*:mailout:] /:*:_dw:/

    output /:*:_nl: Aw, crud.  mailfilter.crm broke.  Here's the error: :*:_nl:/
    output /:*:broken_program_message:/
    output [stderr] /:*:_nl: ERROR: mailfilter.crm broke.  Here's the error: :*:_nl:/
    output [stderr] /ERROR: :*:broken_program_message:/
}
exit /:*:program_fault_exit_code:/


######################################################################3
#
#              Library insertions start here.
insert maillib.crm

